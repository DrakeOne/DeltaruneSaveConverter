<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Deltarune Save Converter Switch ↔ PC</title>
  <style>
    body { font-family: Arial, sans-serif; background: #181c24; color: #fff; margin: 0; padding: 0; }
    .container { max-width: 700px; margin: 40px auto; background: #23283a; border-radius: 12px; padding: 32px; box-shadow: 0 0 16px #0008; }
    h1 { text-align: center; }
    input[type="file"] { margin: 16px 0; }
    .slot-list { margin: 24px 0; }
    .slot { background: #222; margin: 8px 0; padding: 8px 12px; border-radius: 6px; }
    .actions { margin: 24px 0; text-align: center; }
    button { background: #4e7fff; color: #fff; border: none; padding: 10px 24px; border-radius: 6px; font-size: 1.1em; cursor: pointer; }
    button:disabled { background: #888; }
    .output { margin: 24px 0; background: #111; padding: 12px; border-radius: 6px; }
    .footer { text-align: center; margin-top: 40px; color: #aaa; font-size: 0.9em; }
    a { color: #7ecfff; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Deltarune Save Converter<br><span style="font-size:0.6em;">Switch ↔ PC (Ch1, Ch2, Ch3, Ch4)</span></h1>
    <input type="file" id="fileInput" accept=".sav,.txt,.json" />
    <div class="slot-list" id="slotList"></div>
    <div class="actions">
      <button id="convertToPC" disabled>Convertir a PC</button>
      <button id="convertToSwitch" disabled>Convertir a Switch</button>
    </div>
    <div class="output" id="output"></div>
    <div class="footer">
      Hecho por <a href="https://github.com/DrakeOne" target="_blank">DrakeOne</a> & AI · <a href="https://github.com/DrakeOne/DeltaruneSaveConverter" target="_blank">Repositorio original</a>
    </div>
  </div>
  <script>
    // Utilidades GMSList
    function decodeGMSList(hex) {
      // Solo decodifica arrays de reales (tipo 0)
      if (!/^2[EF]010000/.test(hex)) return [];
      const bytes = [];
      for (let i = 0; i < hex.length; i += 2) bytes.push(parseInt(hex.substr(i, 2), 16));
      const count = bytes[4] + (bytes[5]<<8) + (bytes[6]<<16) + (bytes[7]<<24);
      let pos = 8, arr = [];
      for (let i = 0; i < count; i++) {
        const type = bytes[pos]; pos += 4;
        if (type === 0) { // real
          const dv = new DataView(new Uint8Array(bytes.slice(pos, pos+8)).buffer);
          arr.push(dv.getFloat64(0, true));
          pos += 8;
        } else if (type === 1) { // string
          const len = bytes[pos] + (bytes[pos+1]<<8) + (bytes[pos+2]<<16) + (bytes[pos+3]<<24);
          pos += 4;
          arr.push(String.fromCharCode(...bytes.slice(pos, pos+len)));
          pos += len;
        }
      }
      return arr;
    }
    function encodeGMSList(arr, type="real") {
      // Solo soporta arrays de reales o strings
      let bytes = [0x2F,0x01,0x00,0x00, arr.length,0,0,0];
      for (let v of arr) {
        if (type === "real") {
          bytes.push(0,0,0,0);
          const buf = new ArrayBuffer(8);
          new DataView(buf).setFloat64(0, parseFloat(v), true);
          bytes.push(...new Uint8Array(buf));
        } else {
          bytes.push(1,0,0,0);
          bytes.push(v.length,0,0,0);
          for (let c of v) bytes.push(c.charCodeAt(0));
        }
      }
      return bytes.map(b => b.toString(16).padStart(2,"0")).join("").toUpperCase();
    }

    // Detección de slots y capítulos
    function detectSlots(json) {
      const slots = [];
      for (const key in json) {
        const m = key.match(/^filech(\d)_(\d)/);
        if (m) {
          slots.push({ key, chapter: parseInt(m[1]), slot: parseInt(m[2])+1 });
        }
      }
      return slots.sort((a,b) => a.chapter - b.chapter || a.slot - b.slot);
    }

    // Conversión principal
    function convertSlotToPC(content) {
      const lines = content.split(/\r?\n/);
      let out = [];
      out.push(lines[0]); // nombre
      // Nombres de personajes
      out.push(...decodeGMSList(lines[1]));
      let i = 2;
      while (i < lines.length) {
        if (/^2[EF]010000/.test(lines[i])) {
          const arr = decodeGMSList(lines[i]);
          out.push(...arr);
          i++;
        } else {
          out.push(lines[i]);
          i++;
        }
      }
      return out.join("\n");
    }
    function convertSlotToSwitch(content) {
      const lines = content.split(/\r?\n/);
      let out = [];
      out.push(lines[0]); // nombre
      out.push(encodeGMSList(lines.slice(1,7), "string")); // nombres
      let i = 7;
      while (i < lines.length) {
        // Detectar arrays grandes (flags, items, etc.)
        if (i === lines.length-9999-3) { // flags (Ch1/Ch3/Ch4)
          out.push(encodeGMSList(lines.slice(i,i+9999)));
          i += 9999;
        } else if (i === lines.length-2500-3) { // flags (Ch2)
          out.push(encodeGMSList(lines.slice(i,i+2500)));
          i += 2500;
        } else {
          out.push(lines[i]);
          i++;
        }
      }
      return out.join("\n");
    }

    // Interfaz
    let fileContent = null, json = null, slots = [];
    document.getElementById("fileInput").addEventListener("change", function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        try {
          json = JSON.parse(ev.target.result);
          slots = detectSlots(json);
          fileContent = json;
          showSlots();
        } catch {
          document.getElementById("output").innerText = "Archivo no válido o no es un .sav de Deltarune Switch.";
        }
      };
      reader.readAsText(file);
    });

    function showSlots() {
      const list = document.getElementById("slotList");
      list.innerHTML = "<b>Slots detectados:</b><br>";
      for (const slot of slots) {
        list.innerHTML += `<div class="slot">Capítulo ${slot.chapter} - Slot ${slot.slot} <code>${slot.key}</code></div>`;
      }
      document.getElementById("convertToPC").disabled = false;
      document.getElementById("convertToSwitch").disabled = false;
    }

    document.getElementById("convertToPC").onclick = function() {
      let out = {};
      for (const slot of slots) {
        out[slot.key] = convertSlotToPC(fileContent[slot.key]);
      }
      downloadFile(JSON.stringify(out, null, 2), "deltarune_pc.json");
      document.getElementById("output").innerText = "¡Conversión a PC completada! Descarga el archivo generado.";
    };
    document.getElementById("convertToSwitch").onclick = function() {
      let out = {};
      for (const slot of slots) {
        out[slot.key] = convertSlotToSwitch(fileContent[slot.key]);
      }
      downloadFile(JSON.stringify(out, null, 2), "deltarune_switch.json");
      document.getElementById("output").innerText = "¡Conversión a Switch completada! Descarga el archivo generado.";
    };

    function downloadFile(content, filename) {
      const blob = new Blob([content], {type: "application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }
  </script>
</body>
</html>
